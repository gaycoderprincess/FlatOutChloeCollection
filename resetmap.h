namespace NewResetMap {
	bool bNoReset = false;

	class ResetMap {
	public:
		float fResetMapTopLeft[2]; // +0
		float fResetMapBottomRight[2]; // +8
		float fResetMapSize[2]; // +10
		uint8_t data[0x8000];
	} gResetMap;
	bool bResetMapValid = false;

	uint8_t aGetResetmapValue[] = {0x83, 0xEC, 0x8, 0x8B, 0x44, 0x24, 0xC, 0xD9, 0x1, 0xD8, 0x20, 0xD8, 0x48, 0x10, 0xD9, 0x5C, 0x24, 0x4, 0xD9, 0x41, 0x8, 0xD8, 0x60, 0x4, 0xD8, 0x48, 0x14, 0xD9, 0x1C, 0x24, 0xD9, 0xEE, 0xD9, 0x44, 0x24, 0x4, 0xD8, 0xD1, 0xDF, 0xE0, 0xF6, 0xC4, 0x5, 0xF, 0x8B, 0xCE, 0x0, 0x0, 0x0, 0xD9, 0x5, 0x48, 0xB8, 0x6D, 0x0, 0xD8, 0xD1, 0xDF, 0xE0, 0xDD, 0xD9, 0xF6, 0xC4, 0x5, 0xF, 0x8B, 0xB9, 0x0, 0x0, 0x0, 0xD9, 0x4, 0x24, 0xD8, 0xD2, 0xDF, 0xE0, 0xDD, 0xDA, 0xF6, 0xC4, 0x5, 0xF, 0x8B, 0xB3, 0x0, 0x0, 0x0, 0xDE, 0xD9, 0xDF, 0xE0, 0xF6, 0xC4, 0x5, 0xF, 0x8B, 0xAA, 0x0, 0x0, 0x0, 0x8B, 0x4, 0x24, 0x53, 0x8B, 0xD0, 0x55, 0x56, 0x8B, 0x74, 0x24, 0x10, 0x57, 0x8B, 0xD8, 0xC1, 0xFA, 0x17, 0x8B, 0xFE, 0xD, 0x0, 0x0, 0x80, 0xFF, 0x81, 0xE2, 0xFF, 0x0, 0x0, 0x0, 0xC1, 0xFF, 0x17, 0xC1, 0xE0, 0x8, 0x83, 0xEA, 0x7F, 0x8B, 0xEE, 0x81, 0xE7, 0xFF, 0x0, 0x0, 0x0, 0x81, 0xCE, 0x0, 0x0, 0x80, 0xFF, 0xB9, 0x1F, 0x0, 0x0, 0x0, 0x2B, 0xCA, 0xD3, 0xE8, 0x83, 0xEF, 0x7F, 0xC1, 0xE6, 0x8, 0xB9, 0x1F, 0x0, 0x0, 0x0, 0x2B, 0xCF, 0xD3, 0xEE, 0xC1, 0xFB, 0x1F, 0x33, 0xC3, 0xC1, 0xFD, 0x1F, 0x2B, 0xC3, 0x33, 0xF5, 0xC1, 0xFA, 0x1F, 0xC1, 0xFF, 0x1F, 0x2B, 0xF5, 0xF7, 0xD2, 0x23, 0xC2, 0xF7, 0xD7, 0x23, 0xF7, 0xC1, 0xE0, 0x8, 0x5F, 0x3, 0xC6, 0x5E, 0x8B, 0xC8, 0x81, 0xF9, 0xFF, 0xFF, 0x0, 0x0, 0x5D, 0x5B, 0x77, 0x2D, 0x8B, 0x54, 0x24, 0xC, 0xD1, 0xF8, 0xF, 0xB6, 0x44, 0x10, 0x18, 0x80, 0xE1, 0x1, 0x2, 0xC9, 0x2, 0xC9, 0xD3, 0xE8, 0x83, 0xE0, 0xF, 0x83, 0xC4, 0x8, 0xC2, 0x4, 0x0, 0xDD, 0xD8, 0x33, 0xC0, 0xDD, 0xD8, 0x83, 0xC4, 0x8, 0xC2, 0x4, 0x0, 0xDD, 0xD9, 0xDD, 0xD8, 0x33, 0xC0, 0x83, 0xC4, 0x8, 0xC2, 0x4, 0x0};
	static inline auto GetResetmapValue = (uint32_t(__thiscall*)(NyaVec3*, ResetMap*))aGetResetmapValue;

	bool ShouldReset(Player* ply) {
		if (!bResetMapValid) return false;
		if (bNoReset) return false;

		auto value = GetResetmapValue(&ply->pCar->GetMatrix()->p, &gResetMap);
		return (value & 1) != 0;
	}

	bool ShouldPromptReset(Player* ply) {
		if (!bResetMapValid) return false;
		if (bNoReset) return false;

		auto value = GetResetmapValue(&ply->pCar->GetMatrix()->p, &gResetMap);
		return (value & 2) != 0;
	}

	void OnMapLoad() {
		bResetMapValid = false;

		auto path = (std::string)pEnvironment->sStagePath.Get();
		auto path2 = path;
		path += "data/resetmap.4b";
		path2 += "data/resetmap.bed";

		if (!DoesFileExist(path.c_str())) return;
		if (!DoesFileExist(path2.c_str())) return;

		size_t size = 0;
		auto file = ReadFileFromBfs(path.c_str(), size);
		if (size > 0x8000) size = 0x8000;
		memcpy(gResetMap.data, file, size);

		auto config = ReadTOMLFromBfsLUAHack(path2.c_str());
		gResetMap.fResetMapTopLeft[0] = config["ResetMapTopLeft"][0].value_or(0.0f);
		gResetMap.fResetMapTopLeft[1] = config["ResetMapTopLeft"][1].value_or(0.0f);
		gResetMap.fResetMapBottomRight[0] = config["ResetMapBottomRight"][0].value_or(0.0f);
		gResetMap.fResetMapBottomRight[1] = config["ResetMapBottomRight"][1].value_or(0.0f);
		gResetMap.fResetMapSize[0] = 256.0 / (gResetMap.fResetMapBottomRight[0] - gResetMap.fResetMapTopLeft[0]);
		gResetMap.fResetMapSize[1] = 256.0 / (gResetMap.fResetMapBottomRight[1] - gResetMap.fResetMapTopLeft[1]);

		//NyaHookLib::Patch<uint8_t>(0x450B20, 0xC3); // remove out of map arrow

		bResetMapValid = true;
	}

	void CheckOutOfTrack() {
		if (!bResetMapValid) return;
		if (pLoadingScreen) return;
		if (GetGameState() != GAME_STATE_RACE) return;

		for (int i = 0; i < pPlayerHost->GetNumPlayers(); i++) {
			auto ply = GetPlayer(i);
			if (!ply) continue;
			ply->nIsOutOfTrack = ShouldPromptReset(ply);
		}
	}

	ChloeHook Init([]() {
		DWORD oldProt;
		static float f256 = 256.0;
		NyaHookLib::Patch((uintptr_t)(&aGetResetmapValue[0x33]), &f256);
		VirtualProtect(aGetResetmapValue, sizeof(aGetResetmapValue), PAGE_EXECUTE_READWRITE, &oldProt);

		ChloeEvents::MapLoadEvent.AddHandler(OnMapLoad);
	});
}